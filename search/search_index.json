{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"18738 Engineering Embedded Systems This site is constructed with MkDocs. For full documentation visit mkdocs.org . This course page is under construction, please excuse our mess!","title":"Home"},{"location":"#18738-engineering-embedded-systems","text":"This site is constructed with MkDocs. For full documentation visit mkdocs.org .","title":"18738 Engineering Embedded Systems"},{"location":"#this-course-page-is-under-construction-please-excuse-our-mess","text":"","title":"This course page is under construction, please excuse our mess!"},{"location":"coursehardware/","text":"Course Hardware Discovery STM32F3VCT6 link to purchasing overview of hardware capabilities applicability to the course Documentation for the Discovery Board TODO: Getting Started Cables Connecting the Board","title":"Course Hardware"},{"location":"coursehardware/#course-hardware","text":"","title":"Course Hardware"},{"location":"coursehardware/#discovery-stm32f3vct6","text":"link to purchasing overview of hardware capabilities applicability to the course","title":"Discovery STM32F3VCT6"},{"location":"coursehardware/#documentation-for-the-discovery-board","text":"TODO:","title":"Documentation for the Discovery Board"},{"location":"coursehardware/#getting-started","text":"Cables Connecting the Board","title":"Getting Started"},{"location":"mapfiles/","text":"Arm Toolchain: Map Files Basic Functionality Map files are created by a directive to the linker. arm-none-eabi-ld main.o -T linker.ld --cref -Map main.map -o main.elf The output of the linking process is a Map file. The notable elements in the map file are starting addresses, lengths of variables and sections, and symbols exported for startup code. Below you can see the variables from the main.c file (global_constant => .rodata) and (global_variable => .bss) their addresses and lengths. Map File Listing for Example Snippet Linker script and memory map LOAD main.o 0x10002000 _stack_start = (ORIGIN (CCRAM) + LENGTH (CCRAM)) .text 0x08000000 0x48 *(.isr_vector) *(.text) .text 0x08000000 0x44 main.o 0x08000000 main *(.rodata) .rodata 0x08000044 0x4 main.o 0x08000044 global_constant 0x08000048 . = ALIGN (0x4) 0x08000048 _end_text = . 0x08000048 _la_data = LOADADDR (.data) .glue_7 0x08000048 0x0 .glue_7 0x08000048 0x0 linker stubs .glue_7t 0x08000048 0x0 .glue_7t 0x08000048 0x0 linker stubs .vfp11_veneer 0x08000048 0x0 .vfp11_veneer 0x08000048 0x0 linker stubs .v4_bx 0x08000048 0x0 .v4_bx 0x08000048 0x0 linker stubs .iplt 0x08000048 0x0 .iplt 0x08000048 0x0 main.o .rel.dyn 0x08000048 0x0 .rel.iplt 0x08000048 0x0 main.o .data 0x20000000 0x0 load address 0x08000048 0x20000000 _start_data = . *(.data) .data 0x20000000 0x0 main.o 0x20000000 _end_data = . 0x20000000 . = ALIGN (0x4) .igot.plt 0x20000000 0x0 load address 0x08000048 .igot.plt 0x20000000 0x0 main.o .bss 0x20000000 0x4 load address 0x08000048 0x20000000 _start_bss = . *(.bss) .bss 0x20000000 0x4 main.o 0x20000000 global_variable 0x20000004 . = ALIGN (0x4) 0x20000004 _end_bss = . OUTPUT(main.elf elf32-littlearm) LOAD linker stubs .debug_info 0x00000000 0xe9 .debug_info 0x00000000 0xe9 main.o .debug_abbrev 0x00000000 0x9a .debug_abbrev 0x00000000 0x9a main.o .debug_aranges 0x00000000 0x20 .debug_aranges 0x00000000 0x20 main.o .debug_line 0x00000000 0x165 .debug_line 0x00000000 0x165 main.o .debug_str 0x00000000 0x10e .debug_str 0x00000000 0x10e main.o 0x14b (size before relaxing) .comment 0x00000000 0x45 .comment 0x00000000 0x45 main.o 0x46 (size before relaxing) .ARM.attributes 0x00000000 0x2e .ARM.attributes 0x00000000 0x2e main.o .debug_frame 0x00000000 0x38 .debug_frame 0x00000000 0x38 main.o Cross Reference Table Symbol File global_constant main.o global_variable main.o main main.o","title":"Toolchain - map files"},{"location":"mapfiles/#arm-toolchain-map-files","text":"","title":"Arm Toolchain: Map Files"},{"location":"mapfiles/#basic-functionality","text":"Map files are created by a directive to the linker. arm-none-eabi-ld main.o -T linker.ld --cref -Map main.map -o main.elf The output of the linking process is a Map file. The notable elements in the map file are starting addresses, lengths of variables and sections, and symbols exported for startup code. Below you can see the variables from the main.c file (global_constant => .rodata) and (global_variable => .bss) their addresses and lengths.","title":"Basic Functionality"},{"location":"mapfiles/#map-file-listing-for-example-snippet","text":"Linker script and memory map LOAD main.o 0x10002000 _stack_start = (ORIGIN (CCRAM) + LENGTH (CCRAM)) .text 0x08000000 0x48 *(.isr_vector) *(.text) .text 0x08000000 0x44 main.o 0x08000000 main *(.rodata) .rodata 0x08000044 0x4 main.o 0x08000044 global_constant 0x08000048 . = ALIGN (0x4) 0x08000048 _end_text = . 0x08000048 _la_data = LOADADDR (.data) .glue_7 0x08000048 0x0 .glue_7 0x08000048 0x0 linker stubs .glue_7t 0x08000048 0x0 .glue_7t 0x08000048 0x0 linker stubs .vfp11_veneer 0x08000048 0x0 .vfp11_veneer 0x08000048 0x0 linker stubs .v4_bx 0x08000048 0x0 .v4_bx 0x08000048 0x0 linker stubs .iplt 0x08000048 0x0 .iplt 0x08000048 0x0 main.o .rel.dyn 0x08000048 0x0 .rel.iplt 0x08000048 0x0 main.o .data 0x20000000 0x0 load address 0x08000048 0x20000000 _start_data = . *(.data) .data 0x20000000 0x0 main.o 0x20000000 _end_data = . 0x20000000 . = ALIGN (0x4) .igot.plt 0x20000000 0x0 load address 0x08000048 .igot.plt 0x20000000 0x0 main.o .bss 0x20000000 0x4 load address 0x08000048 0x20000000 _start_bss = . *(.bss) .bss 0x20000000 0x4 main.o 0x20000000 global_variable 0x20000004 . = ALIGN (0x4) 0x20000004 _end_bss = . OUTPUT(main.elf elf32-littlearm) LOAD linker stubs .debug_info 0x00000000 0xe9 .debug_info 0x00000000 0xe9 main.o .debug_abbrev 0x00000000 0x9a .debug_abbrev 0x00000000 0x9a main.o .debug_aranges 0x00000000 0x20 .debug_aranges 0x00000000 0x20 main.o .debug_line 0x00000000 0x165 .debug_line 0x00000000 0x165 main.o .debug_str 0x00000000 0x10e .debug_str 0x00000000 0x10e main.o 0x14b (size before relaxing) .comment 0x00000000 0x45 .comment 0x00000000 0x45 main.o 0x46 (size before relaxing) .ARM.attributes 0x00000000 0x2e .ARM.attributes 0x00000000 0x2e main.o .debug_frame 0x00000000 0x38 .debug_frame 0x00000000 0x38 main.o Cross Reference Table Symbol File global_constant main.o global_variable main.o main main.o","title":"Map File Listing for Example Snippet"},{"location":"objdump/","text":"Arm Toolchain: arm-none-eabi-objdump Basic Functionality arm-none-eabi-objdump displays information about object files created during the compilation process File Headers Section Headers Symbol Tables Disassembly Usage running arm-none-eabi-objdump will print out all the options that the tool can take as arguments and parameters. Use Case examining the assembly for optimization understanding what the compiler has generated This can be useful when setting the compiler to optimize code, as the optimizer can take some liberties. It doesn't understand what the programmer has intended and only follows some rules. As a consequence some insidious defects can appear that can manifest as timing errors, incorrect behavior, or a program that doesn't work at all. Example Source Listing #include<stdint.h> const uint32_t global_constant = 3; uint32_t global_variable = 0; int main(void) { uint32_t result = 0; global_variable = 10; for(uint32_t i = 0; i<global_constant; i++) { global_variable += global_variable; } result = global_variable; return result; } File Header arm-none-eabi-objdump -f main.o This command outputs basic information about the object file. It's useful to initially understand what kind of file the object file is. It also has utility in the security domain for identifying the type of file from the header information and what some basic attributes are. main.o: file format elf32-littlearm architecture: armv7e-m, flags 0x00000011: HAS_RELOC, HAS_SYMS start address 0x00000000 Section Header arm-none-eabi-objdump -h main.o With the command listed above, we're listing out the section headers for the object file compiled from the example code listing. Each of the sections listed in the output are relocable in the linker file and should be assembled correctly for the arm binary to work in the STM32F3. The sections of interest for this object file are .text, .data, .bss, and .rodata. The compiler will create sections as it needs, so referring to the compiler documentation may be needed to interpret the output well enough to perform any relocations. scott@raven:$ arm-none-eabi-objdump -h main.o main.o: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000044 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000000 00000000 00000000 00000078 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 00000000 00000000 00000078 2**2 ALLOC 3 .rodata 00000004 00000000 00000000 00000078 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .debug_info 000000e9 00000000 00000000 0000007c 2**0 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 5 .debug_abbrev 0000009a 00000000 00000000 00000165 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 6 .debug_aranges 00000020 00000000 00000000 000001ff 2**0 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 7 .debug_line 00000167 00000000 00000000 0000021f 2**0 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 8 .debug_str 0000014b 00000000 00000000 00000386 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 9 .comment 00000046 00000000 00000000 000004d1 2**0 CONTENTS, READONLY 10 .debug_frame 00000038 00000000 00000000 00000518 2**2 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 11 .ARM.attributes 0000002e 00000000 00000000 00000550 2**0 CONTENTS, READONLY Symbol Table arm-none-eabi-objdump -t main.o The output codes are fairly cryptic and more than what should be included in this page. Refer to man arm-none-eabi-objdump for details on what each column means and how to decode the values in each. That said, we can see where the variables from the sample listing have been allocated to. The names of interest are global_constant , global_variable , and main . main.o: file format elf32-littlearm SYMBOL TABLE: 00000000 l df *ABS* 00000000 main.c 00000000 l d .text 00000000 .text 00000000 l d .data 00000000 .data 00000000 l d .bss 00000000 .bss 00000000 l d .rodata 00000000 .rodata 00000000 l d .debug_info 00000000 .debug_info 00000000 l d .debug_abbrev 00000000 .debug_abbrev 00000000 l d .debug_aranges 00000000 .debug_aranges 00000000 l d .debug_line 00000000 .debug_line 00000000 l d .debug_str 00000000 .debug_str 00000000 l d .debug_frame 00000000 .debug_frame 00000000 l d .comment 00000000 .comment 00000000 l d .ARM.attributes 00000000 .ARM.attributes 00000000 g O .rodata 00000004 global_constant 00000000 g O .bss 00000004 global_variable 00000000 g F .text 00000044 main Disassembly arm-none-eabi-objdump -D main.o This is a partial listing of the command as the -D option prints out the disassembly for all sections. Use the -d option to disassemble the executable sections, and remember that the executable code is typically placed in the .text section. main.o: file format elf32-littlearm Disassembly of section .text: 00000000 <main>: 0: b480 push {r7} 2: b083 sub sp, #12 4: af00 add r7, sp, #0 6: 2300 movs r3, #0 8: 603b str r3, [r7, #0] a: 4b0d ldr r3, [pc, #52] @ (40 <main+0x40>) c: 220a movs r2, #10 e: 601a str r2, [r3, #0] 10: 2300 movs r3, #0 12: 607b str r3, [r7, #4] 14: e007 b.n 26 <main+0x26> 16: 4b0a ldr r3, [pc, #40] @ (40 <main+0x40>) 18: 681b ldr r3, [r3, #0] 1a: 005b lsls r3, r3, #1 1c: 4a08 ldr r2, [pc, #32] @ (40 <main+0x40>) 1e: 6013 str r3, [r2, #0] 20: 687b ldr r3, [r7, #4] 22: 3301 adds r3, #1 24: 607b str r3, [r7, #4] 26: 2203 movs r2, #3 28: 687b ldr r3, [r7, #4] 2a: 4293 cmp r3, r2 2c: d3f3 bcc.n 16 <main+0x16> 2e: 4b04 ldr r3, [pc, #16] @ (40 <main+0x40>) 30: 681b ldr r3, [r3, #0] 32: 603b str r3, [r7, #0] 34: 683b ldr r3, [r7, #0] 36: 4618 mov r0, r3 38: 370c adds r7, #12 3a: 46bd mov sp, r7 3c: bc80 pop {r7} 3e: 4770 bx lr 40: 00000000 andeq r0, r0, r0 Disassembly of section .rodata: 00000000 <global_constant>: 0: 00000003 andeq r0, r0, r3 Full Contents arm-none-eabi-objdump -s main.o This command dumps the full contents of the object file and includes each part of the assembly as hexcodes within the sections they're allocated to. This is useful as a cursory examination of any strings that are embedded in the object file, and to see what instructions are within each section created by the compiler. scott@raven:~/Desktop/17638/disassembly_tools$ arm-none-eabi-objdump -s main.o main.o: file format elf32-littlearm Contents of section .text: 0000 80b483b0 00af0023 3b600d4b 0a221a60 .......#;`.K.\".` 0010 00237b60 07e00a4b 1b685b00 084a1360 .#{`...K.h[..J.` 0020 7b680133 7b600322 7b689342 f3d3044b {h.3{`.\"{h.B...K 0030 1b683b60 3b681846 0c37bd46 80bc7047 .h;`;h.F.7.F..pG 0040 00000000 .... Contents of section .rodata: 0000 03000000 .... Contents of section .debug_info: 0000 e5000000 05000104 00000000 04330000 .............3.. 0010 001df000 0000f700 00000000 00004400 ..............D. 0020 00000000 00000101 063f0100 00010108 .........?...... 0030 00000000 01020523 01000001 02072000 .......#...... . 0040 00000104 05360100 00029700 0000024f .....6.........O 0050 19550000 00010407 0e000000 010805d2 .U.............. 0060 00000001 0807b400 00000504 05696e74 .............int 0070 00010407 a7000000 022d0100 00033014 .........-....0. 0080 49000000 06780000 00038700 00000410 I....x.......... 0090 84000000 05030000 000003e0 00000006 ................ 00a0 0a780000 00050300 00000007 a2000000 .x.............. 00b0 0109056a 00000000 00000044 00000001 ...j.......D.... 00c0 9c08cb00 0000010b 0e780000 00029170 .........x.....p 00d0 09100000 001e0000 000a6900 010d1278 ..........i....x 00e0 00000002 91740000 00 .....t... Contents of section .debug_abbrev: 0000 0124000b 0b3e0b03 0e000002 1600030e .$...>.......... 0010 3a0b3b0b 390b4913 00000334 00030e3a :.;.9.I....4...: 0020 21013b0b 390b4913 3f190218 00000411 !.;.9.I.?....... 0030 01250e13 0b030e1b 0e110112 06101700 .%.............. 0040 00052400 0b0b3e0b 03080000 06260049 ..$...>......&.I 0050 13000007 2e013f19 030e3a0b 3b0b390b ......?...:.;.9. 0060 27194913 11011206 40187a19 00000834 '.I.....@.z....4 0070 00030e3a 0b3b0b39 0b491302 18000009 ...:.;.9.I...... 0080 0b011101 12060000 0a340003 083a0b3b .........4...:.; 0090 0b390b49 13021800 0000 .9.I...... Contents of section .debug_aranges: 0000 1c000000 02000000 00000400 00000000 ................ 0010 00000000 44000000 00000000 00000000 ....D........... Contents of section .debug_line: 0000 63010000 03002801 00000201 fb0e0d00 c.....(......... 0010 01010101 00000001 0000012f 686f6d65 .........../home 0020 2f73636f 74742f44 65736b74 6f702f31 /scott/Desktop/1 0030 37363338 2f41524d 5f546f6f 6c636861 7638/ARM_Toolcha 0040 696e2f61 726d2d67 6e752d74 6f6f6c63 in/arm-gnu-toolc 0050 6861696e 2d31332e 332e7265 6c312d78 hain-13.3.rel1-x 0060 38365f36 342d6172 6d2d6e6f 6e652d65 86_64-arm-none-e 0070 6162692f 61726d2d 6e6f6e65 2d656162 abi/arm-none-eab 0080 692f696e 636c7564 652f6d61 6368696e i/include/machin 0090 65002f68 6f6d652f 73636f74 742f4465 e./home/scott/De 00a0 736b746f 702f3137 3633382f 41524d5f sktop/17638/ARM_ 00b0 546f6f6c 63686169 6e2f6172 6d2d676e Toolchain/arm-gn 00c0 752d746f 6f6c6368 61696e2d 31332e33 u-toolchain-13.3 00d0 2e72656c 312d7838 365f3634 2d61726d .rel1-x86_64-arm 00e0 2d6e6f6e 652d6561 62692f61 726d2d6e -none-eabi/arm-n 00f0 6f6e652d 65616269 2f696e63 6c756465 one-eabi/include 0100 2f737973 00006d61 696e2e63 00000000 /sys..main.c.... 0110 5f646566 61756c74 5f747970 65732e68 _default_types.h 0120 00010000 5f737464 696e742e 68000200 ...._stdint.h... 0130 00000501 00050200 00000003 0901050e ................ 0140 3d05152f 05123d05 052e0516 22052d00 =../..=.....\".-. 0150 02040356 051a0002 04013c05 0c4e3d05 ...V......<..N=. 0160 01210207 000101 .!..... Contents of section .debug_str: 0000 756e7369 676e6564 20636861 72006c6f unsigned char.lo 0010 6e672075 6e736967 6e656420 696e7400 ng unsigned int. 0020 73686f72 7420756e 7369676e 65642069 short unsigned i 0030 6e740047 4e552043 31372031 332e332e nt.GNU C17 13.3. 0040 31203230 32343036 3134202d 6d637075 1 20240614 -mcpu 0050 3d636f72 7465782d 6d34202d 6d746875 =cortex-m4 -mthu 0060 6d62202d 6d666c6f 61742d61 62693d73 mb -mfloat-abi=s 0070 6f667420 2d6d6172 63683d61 726d7637 oft -march=armv7 0080 652d6d20 2d670067 6c6f6261 6c5f636f e-m -g.global_co 0090 6e737461 6e74005f 5f75696e 7433325f nstant.__uint32_ 00a0 74006d61 696e0075 6e736967 6e656420 t.main.unsigned 00b0 696e7400 6c6f6e67 206c6f6e 6720756e int.long long un 00c0 7369676e 65642069 6e740072 6573756c signed int.resul 00d0 74006c6f 6e67206c 6f6e6720 696e7400 t.long long int. 00e0 676c6f62 616c5f76 61726961 626c6500 global_variable. 00f0 6d61696e 2e63002f 686f6d65 2f73636f main.c./home/sco 0100 74742f44 65736b74 6f702f31 37363338 tt/Desktop/17638 0110 2f646973 61737365 6d626c79 5f746f6f /disassembly_too 0120 6c730073 686f7274 20696e74 0075696e ls.short int.uin 0130 7433325f 74006c6f 6e672069 6e740073 t32_t.long int.s 0140 69676e65 64206368 617200 igned char. Contents of section .comment: 0000 00474343 3a202841 726d2047 4e552054 .GCC: (Arm GNU T 0010 6f6f6c63 6861696e 2031332e 332e5265 oolchain 13.3.Re 0020 6c312028 4275696c 64206172 6d2d3133 l1 (Build arm-13 0030 2e323429 29203133 2e332e31 20323032 .24)) 13.3.1 202 0040 34303631 3400 40614. Contents of section .debug_frame: 0000 0c000000 ffffffff 0100027c 0e0c0d00 ...........|.... 0010 24000000 00000000 00000000 44000000 $...........D... 0020 410e0487 01410e10 410d075a 0e04410d A....A..A..Z..A. 0030 0d41c70e 00000000 .A...... Contents of section .ARM.attributes: 0000 412d0000 00616561 62690001 23000000 A-...aeabi..#... 0010 0537452d 4d00060d 074d0902 12041401 .7E-M....M...... 0020 15011703 18011901 1a011e06 2201 ............\". Intermixed arm-none-eabi-objdump -S main.o Getting intermixed output 'intermixes' the assembly with the source code so it is easier for the humans to follow along. This is useful in determining what the compiler is creating, line by line. main.o: file format elf32-littlearm Disassembly of section .text: 00000000 <main>: arm-none-eabi-objdump: Warning: source file /home/scott/Desktop/17638/disassembly_tools/main.c is more recent than object file uint32_t global_variable = 0; int main(void) { uint32_t result = 0; global_variable = 10; 0: b480 push {r7} 2: b083 sub sp, #12 4: af00 add r7, sp, #0 for(uint32_t i = 0; i<global_constant; i++) 6: 2300 movs r3, #0 8: 603b str r3, [r7, #0] { a: 4b0d ldr r3, [pc, #52] @ (40 <main+0x40>) c: 220a movs r2, #10 e: 601a str r2, [r3, #0] global_variable += global_variable; 10: 2300 movs r3, #0 12: 607b str r3, [r7, #4] 14: e007 b.n 26 <main+0x26> } result = global_variable; 16: 4b0a ldr r3, [pc, #40] @ (40 <main+0x40>) 18: 681b ldr r3, [r3, #0] 1a: 005b lsls r3, r3, #1 1c: 4a08 ldr r2, [pc, #32] @ (40 <main+0x40>) 1e: 6013 str r3, [r2, #0] global_variable += global_variable; 20: 687b ldr r3, [r7, #4] 22: 3301 adds r3, #1 24: 607b str r3, [r7, #4] 26: 2203 movs r2, #3 28: 687b ldr r3, [r7, #4] 2a: 4293 cmp r3, r2 2c: d3f3 bcc.n 16 <main+0x16> return result; } 2e: 4b04 ldr r3, [pc, #16] @ (40 <main+0x40>) 30: 681b ldr r3, [r3, #0] 32: 603b str r3, [r7, #0] 34: 683b ldr r3, [r7, #0] 36: 4618 mov r0, r3 38: 370c adds r7, #12 3a: 46bd mov sp, r7 3c: bc80 pop {r7} 3e: 4770 bx lr 40: 00000000 .word 0x00000000","title":"Toolchain - objdump"},{"location":"objdump/#arm-toolchain-arm-none-eabi-objdump","text":"","title":"Arm Toolchain: arm-none-eabi-objdump"},{"location":"objdump/#basic-functionality","text":"arm-none-eabi-objdump displays information about object files created during the compilation process File Headers Section Headers Symbol Tables Disassembly","title":"Basic Functionality"},{"location":"objdump/#usage","text":"running arm-none-eabi-objdump will print out all the options that the tool can take as arguments and parameters.","title":"Usage"},{"location":"objdump/#use-case","text":"examining the assembly for optimization understanding what the compiler has generated This can be useful when setting the compiler to optimize code, as the optimizer can take some liberties. It doesn't understand what the programmer has intended and only follows some rules. As a consequence some insidious defects can appear that can manifest as timing errors, incorrect behavior, or a program that doesn't work at all.","title":"Use Case"},{"location":"objdump/#example","text":"","title":"Example"},{"location":"objdump/#source-listing","text":"#include<stdint.h> const uint32_t global_constant = 3; uint32_t global_variable = 0; int main(void) { uint32_t result = 0; global_variable = 10; for(uint32_t i = 0; i<global_constant; i++) { global_variable += global_variable; } result = global_variable; return result; }","title":"Source Listing"},{"location":"objdump/#file-header","text":"arm-none-eabi-objdump -f main.o This command outputs basic information about the object file. It's useful to initially understand what kind of file the object file is. It also has utility in the security domain for identifying the type of file from the header information and what some basic attributes are. main.o: file format elf32-littlearm architecture: armv7e-m, flags 0x00000011: HAS_RELOC, HAS_SYMS start address 0x00000000","title":"File Header"},{"location":"objdump/#section-header","text":"arm-none-eabi-objdump -h main.o With the command listed above, we're listing out the section headers for the object file compiled from the example code listing. Each of the sections listed in the output are relocable in the linker file and should be assembled correctly for the arm binary to work in the STM32F3. The sections of interest for this object file are .text, .data, .bss, and .rodata. The compiler will create sections as it needs, so referring to the compiler documentation may be needed to interpret the output well enough to perform any relocations. scott@raven:$ arm-none-eabi-objdump -h main.o main.o: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000044 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000000 00000000 00000000 00000078 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 00000000 00000000 00000078 2**2 ALLOC 3 .rodata 00000004 00000000 00000000 00000078 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .debug_info 000000e9 00000000 00000000 0000007c 2**0 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 5 .debug_abbrev 0000009a 00000000 00000000 00000165 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 6 .debug_aranges 00000020 00000000 00000000 000001ff 2**0 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 7 .debug_line 00000167 00000000 00000000 0000021f 2**0 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 8 .debug_str 0000014b 00000000 00000000 00000386 2**0 CONTENTS, READONLY, DEBUGGING, OCTETS 9 .comment 00000046 00000000 00000000 000004d1 2**0 CONTENTS, READONLY 10 .debug_frame 00000038 00000000 00000000 00000518 2**2 CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS 11 .ARM.attributes 0000002e 00000000 00000000 00000550 2**0 CONTENTS, READONLY","title":"Section Header"},{"location":"objdump/#symbol-table","text":"arm-none-eabi-objdump -t main.o The output codes are fairly cryptic and more than what should be included in this page. Refer to man arm-none-eabi-objdump for details on what each column means and how to decode the values in each. That said, we can see where the variables from the sample listing have been allocated to. The names of interest are global_constant , global_variable , and main . main.o: file format elf32-littlearm SYMBOL TABLE: 00000000 l df *ABS* 00000000 main.c 00000000 l d .text 00000000 .text 00000000 l d .data 00000000 .data 00000000 l d .bss 00000000 .bss 00000000 l d .rodata 00000000 .rodata 00000000 l d .debug_info 00000000 .debug_info 00000000 l d .debug_abbrev 00000000 .debug_abbrev 00000000 l d .debug_aranges 00000000 .debug_aranges 00000000 l d .debug_line 00000000 .debug_line 00000000 l d .debug_str 00000000 .debug_str 00000000 l d .debug_frame 00000000 .debug_frame 00000000 l d .comment 00000000 .comment 00000000 l d .ARM.attributes 00000000 .ARM.attributes 00000000 g O .rodata 00000004 global_constant 00000000 g O .bss 00000004 global_variable 00000000 g F .text 00000044 main","title":"Symbol Table"},{"location":"objdump/#disassembly","text":"arm-none-eabi-objdump -D main.o This is a partial listing of the command as the -D option prints out the disassembly for all sections. Use the -d option to disassemble the executable sections, and remember that the executable code is typically placed in the .text section. main.o: file format elf32-littlearm Disassembly of section .text: 00000000 <main>: 0: b480 push {r7} 2: b083 sub sp, #12 4: af00 add r7, sp, #0 6: 2300 movs r3, #0 8: 603b str r3, [r7, #0] a: 4b0d ldr r3, [pc, #52] @ (40 <main+0x40>) c: 220a movs r2, #10 e: 601a str r2, [r3, #0] 10: 2300 movs r3, #0 12: 607b str r3, [r7, #4] 14: e007 b.n 26 <main+0x26> 16: 4b0a ldr r3, [pc, #40] @ (40 <main+0x40>) 18: 681b ldr r3, [r3, #0] 1a: 005b lsls r3, r3, #1 1c: 4a08 ldr r2, [pc, #32] @ (40 <main+0x40>) 1e: 6013 str r3, [r2, #0] 20: 687b ldr r3, [r7, #4] 22: 3301 adds r3, #1 24: 607b str r3, [r7, #4] 26: 2203 movs r2, #3 28: 687b ldr r3, [r7, #4] 2a: 4293 cmp r3, r2 2c: d3f3 bcc.n 16 <main+0x16> 2e: 4b04 ldr r3, [pc, #16] @ (40 <main+0x40>) 30: 681b ldr r3, [r3, #0] 32: 603b str r3, [r7, #0] 34: 683b ldr r3, [r7, #0] 36: 4618 mov r0, r3 38: 370c adds r7, #12 3a: 46bd mov sp, r7 3c: bc80 pop {r7} 3e: 4770 bx lr 40: 00000000 andeq r0, r0, r0 Disassembly of section .rodata: 00000000 <global_constant>: 0: 00000003 andeq r0, r0, r3","title":"Disassembly"},{"location":"objdump/#full-contents","text":"arm-none-eabi-objdump -s main.o This command dumps the full contents of the object file and includes each part of the assembly as hexcodes within the sections they're allocated to. This is useful as a cursory examination of any strings that are embedded in the object file, and to see what instructions are within each section created by the compiler. scott@raven:~/Desktop/17638/disassembly_tools$ arm-none-eabi-objdump -s main.o main.o: file format elf32-littlearm Contents of section .text: 0000 80b483b0 00af0023 3b600d4b 0a221a60 .......#;`.K.\".` 0010 00237b60 07e00a4b 1b685b00 084a1360 .#{`...K.h[..J.` 0020 7b680133 7b600322 7b689342 f3d3044b {h.3{`.\"{h.B...K 0030 1b683b60 3b681846 0c37bd46 80bc7047 .h;`;h.F.7.F..pG 0040 00000000 .... Contents of section .rodata: 0000 03000000 .... Contents of section .debug_info: 0000 e5000000 05000104 00000000 04330000 .............3.. 0010 001df000 0000f700 00000000 00004400 ..............D. 0020 00000000 00000101 063f0100 00010108 .........?...... 0030 00000000 01020523 01000001 02072000 .......#...... . 0040 00000104 05360100 00029700 0000024f .....6.........O 0050 19550000 00010407 0e000000 010805d2 .U.............. 0060 00000001 0807b400 00000504 05696e74 .............int 0070 00010407 a7000000 022d0100 00033014 .........-....0. 0080 49000000 06780000 00038700 00000410 I....x.......... 0090 84000000 05030000 000003e0 00000006 ................ 00a0 0a780000 00050300 00000007 a2000000 .x.............. 00b0 0109056a 00000000 00000044 00000001 ...j.......D.... 00c0 9c08cb00 0000010b 0e780000 00029170 .........x.....p 00d0 09100000 001e0000 000a6900 010d1278 ..........i....x 00e0 00000002 91740000 00 .....t... Contents of section .debug_abbrev: 0000 0124000b 0b3e0b03 0e000002 1600030e .$...>.......... 0010 3a0b3b0b 390b4913 00000334 00030e3a :.;.9.I....4...: 0020 21013b0b 390b4913 3f190218 00000411 !.;.9.I.?....... 0030 01250e13 0b030e1b 0e110112 06101700 .%.............. 0040 00052400 0b0b3e0b 03080000 06260049 ..$...>......&.I 0050 13000007 2e013f19 030e3a0b 3b0b390b ......?...:.;.9. 0060 27194913 11011206 40187a19 00000834 '.I.....@.z....4 0070 00030e3a 0b3b0b39 0b491302 18000009 ...:.;.9.I...... 0080 0b011101 12060000 0a340003 083a0b3b .........4...:.; 0090 0b390b49 13021800 0000 .9.I...... Contents of section .debug_aranges: 0000 1c000000 02000000 00000400 00000000 ................ 0010 00000000 44000000 00000000 00000000 ....D........... Contents of section .debug_line: 0000 63010000 03002801 00000201 fb0e0d00 c.....(......... 0010 01010101 00000001 0000012f 686f6d65 .........../home 0020 2f73636f 74742f44 65736b74 6f702f31 /scott/Desktop/1 0030 37363338 2f41524d 5f546f6f 6c636861 7638/ARM_Toolcha 0040 696e2f61 726d2d67 6e752d74 6f6f6c63 in/arm-gnu-toolc 0050 6861696e 2d31332e 332e7265 6c312d78 hain-13.3.rel1-x 0060 38365f36 342d6172 6d2d6e6f 6e652d65 86_64-arm-none-e 0070 6162692f 61726d2d 6e6f6e65 2d656162 abi/arm-none-eab 0080 692f696e 636c7564 652f6d61 6368696e i/include/machin 0090 65002f68 6f6d652f 73636f74 742f4465 e./home/scott/De 00a0 736b746f 702f3137 3633382f 41524d5f sktop/17638/ARM_ 00b0 546f6f6c 63686169 6e2f6172 6d2d676e Toolchain/arm-gn 00c0 752d746f 6f6c6368 61696e2d 31332e33 u-toolchain-13.3 00d0 2e72656c 312d7838 365f3634 2d61726d .rel1-x86_64-arm 00e0 2d6e6f6e 652d6561 62692f61 726d2d6e -none-eabi/arm-n 00f0 6f6e652d 65616269 2f696e63 6c756465 one-eabi/include 0100 2f737973 00006d61 696e2e63 00000000 /sys..main.c.... 0110 5f646566 61756c74 5f747970 65732e68 _default_types.h 0120 00010000 5f737464 696e742e 68000200 ...._stdint.h... 0130 00000501 00050200 00000003 0901050e ................ 0140 3d05152f 05123d05 052e0516 22052d00 =../..=.....\".-. 0150 02040356 051a0002 04013c05 0c4e3d05 ...V......<..N=. 0160 01210207 000101 .!..... Contents of section .debug_str: 0000 756e7369 676e6564 20636861 72006c6f unsigned char.lo 0010 6e672075 6e736967 6e656420 696e7400 ng unsigned int. 0020 73686f72 7420756e 7369676e 65642069 short unsigned i 0030 6e740047 4e552043 31372031 332e332e nt.GNU C17 13.3. 0040 31203230 32343036 3134202d 6d637075 1 20240614 -mcpu 0050 3d636f72 7465782d 6d34202d 6d746875 =cortex-m4 -mthu 0060 6d62202d 6d666c6f 61742d61 62693d73 mb -mfloat-abi=s 0070 6f667420 2d6d6172 63683d61 726d7637 oft -march=armv7 0080 652d6d20 2d670067 6c6f6261 6c5f636f e-m -g.global_co 0090 6e737461 6e74005f 5f75696e 7433325f nstant.__uint32_ 00a0 74006d61 696e0075 6e736967 6e656420 t.main.unsigned 00b0 696e7400 6c6f6e67 206c6f6e 6720756e int.long long un 00c0 7369676e 65642069 6e740072 6573756c signed int.resul 00d0 74006c6f 6e67206c 6f6e6720 696e7400 t.long long int. 00e0 676c6f62 616c5f76 61726961 626c6500 global_variable. 00f0 6d61696e 2e63002f 686f6d65 2f73636f main.c./home/sco 0100 74742f44 65736b74 6f702f31 37363338 tt/Desktop/17638 0110 2f646973 61737365 6d626c79 5f746f6f /disassembly_too 0120 6c730073 686f7274 20696e74 0075696e ls.short int.uin 0130 7433325f 74006c6f 6e672069 6e740073 t32_t.long int.s 0140 69676e65 64206368 617200 igned char. Contents of section .comment: 0000 00474343 3a202841 726d2047 4e552054 .GCC: (Arm GNU T 0010 6f6f6c63 6861696e 2031332e 332e5265 oolchain 13.3.Re 0020 6c312028 4275696c 64206172 6d2d3133 l1 (Build arm-13 0030 2e323429 29203133 2e332e31 20323032 .24)) 13.3.1 202 0040 34303631 3400 40614. Contents of section .debug_frame: 0000 0c000000 ffffffff 0100027c 0e0c0d00 ...........|.... 0010 24000000 00000000 00000000 44000000 $...........D... 0020 410e0487 01410e10 410d075a 0e04410d A....A..A..Z..A. 0030 0d41c70e 00000000 .A...... Contents of section .ARM.attributes: 0000 412d0000 00616561 62690001 23000000 A-...aeabi..#... 0010 0537452d 4d00060d 074d0902 12041401 .7E-M....M...... 0020 15011703 18011901 1a011e06 2201 ............\".","title":"Full Contents"},{"location":"objdump/#intermixed","text":"arm-none-eabi-objdump -S main.o Getting intermixed output 'intermixes' the assembly with the source code so it is easier for the humans to follow along. This is useful in determining what the compiler is creating, line by line. main.o: file format elf32-littlearm Disassembly of section .text: 00000000 <main>: arm-none-eabi-objdump: Warning: source file /home/scott/Desktop/17638/disassembly_tools/main.c is more recent than object file uint32_t global_variable = 0; int main(void) { uint32_t result = 0; global_variable = 10; 0: b480 push {r7} 2: b083 sub sp, #12 4: af00 add r7, sp, #0 for(uint32_t i = 0; i<global_constant; i++) 6: 2300 movs r3, #0 8: 603b str r3, [r7, #0] { a: 4b0d ldr r3, [pc, #52] @ (40 <main+0x40>) c: 220a movs r2, #10 e: 601a str r2, [r3, #0] global_variable += global_variable; 10: 2300 movs r3, #0 12: 607b str r3, [r7, #4] 14: e007 b.n 26 <main+0x26> } result = global_variable; 16: 4b0a ldr r3, [pc, #40] @ (40 <main+0x40>) 18: 681b ldr r3, [r3, #0] 1a: 005b lsls r3, r3, #1 1c: 4a08 ldr r2, [pc, #32] @ (40 <main+0x40>) 1e: 6013 str r3, [r2, #0] global_variable += global_variable; 20: 687b ldr r3, [r7, #4] 22: 3301 adds r3, #1 24: 607b str r3, [r7, #4] 26: 2203 movs r2, #3 28: 687b ldr r3, [r7, #4] 2a: 4293 cmp r3, r2 2c: d3f3 bcc.n 16 <main+0x16> return result; } 2e: 4b04 ldr r3, [pc, #16] @ (40 <main+0x40>) 30: 681b ldr r3, [r3, #0] 32: 603b str r3, [r7, #0] 34: 683b ldr r3, [r7, #0] 36: 4618 mov r0, r3 38: 370c adds r7, #12 3a: 46bd mov sp, r7 3c: bc80 pop {r7} 3e: 4770 bx lr 40: 00000000 .word 0x00000000","title":"Intermixed"},{"location":"statemachines/","text":"Relevant Links - required literature reading Types of State Machines HSM - Heirarchichal State Machines FSM - Finite State Machine Background What are state machines Linking state machines to the behavior of contolled objects Linking state machines to events and time Processes, Transitions, and Constraints Design Guidance Changes in enviornment state Needed behavioral changes in the application Example: Elements in a State Machine Activities State Transitions Modeling State Machines Modeling techniques for State Machines State Diagrams, State Charts UML SysML Example for State Machine Implementations Implementing State Machines Conditional Statements Code Snippet ```C switch (currentState) { case STATE_IDLE: if (event == EVENT_START) { // Transition to next state currentState = STATE_RUNNING; } break; case STATE_RUNNING: if (event == EVENT_STOP) { // Transition to idle state currentState = STATE_IDLE; } break; // Add more states as needed } ``` - Discussion - Pros/Cons Lookup Tables Code Snippet TODO: Modify example ```C include // Define states typedef enum { STATE_RED, STATE_GREEN, STATE_YELLOW, STATE_MAX } State; // Define events typedef enum { EVENT_TIMER_EXPIRED, EVENT_MAX } Event; // Function prototypes for state actions void redAction(void); void greenAction(void); void yellowAction(void); // State transition structure typedef struct { State currentState; Event event; State nextState; void (*action)(void); } StateTransition; // State transition table StateTransition stateTable[] = { {STATE_RED, EVENT_TIMER_EXPIRED, STATE_GREEN, greenAction}, {STATE_GREEN, EVENT_TIMER_EXPIRED, STATE_YELLOW, yellowAction}, {STATE_YELLOW, EVENT_TIMER_EXPIRED, STATE_RED, redAction} }; // Current state State currentState = STATE_RED; // State action functions void redAction(void) { printf(\"Red Light\\n\"); } void greenAction(void) { printf(\"Green Light\\n\"); } void yellowAction(void) { printf(\"Yellow Light\\n\"); } // Function to handle events void handleEvent(Event event) { for (int i = 0; i < sizeof(stateTable) / sizeof(StateTransition); i++) { if (stateTable[i].currentState == currentState && stateTable[i].event == event) { stateTable[i].action(); currentState = stateTable[i].nextState; break; } } } int main() { // Simulate timer events for (int i = 0; i < 6; i++) { handleEvent(EVENT_TIMER_EXPIRED); } return 0; } ``` - Explanation State and Event Definitions: Enumerations are used to define the states and events. State Transition Table: An array of StateTransition structures maps the current state and event to the next state and the action to be performed. State Action Functions: Functions that define the actions for each state. Event Handling: The handleEvent function iterates through the state transition table to find the matching state and event, performs the action, and updates the current state. Main Function: Simulates timer events to demonstrate the state transitions. Discussion Pros/Cons State Pattern Code Snippet ```C typedef struct State { void ( enter)(void); void ( execute)(void); void (*exit)(void); } State; State idleState = {idleEnter, idleExecute, idleExit}; State runningState = {runningEnter, runningExecute, runningExit}; State* currentState = &idleState; void changeState(State* newState) { currentState->exit(); currentState = newState; currentState->enter(); } void update() { currentState->execute(); } include // Forward declarations of state structures typedef struct State State; // Function pointers for state actions typedef void (*StateAction)(void); // State structure struct State { StateAction enter; StateAction execute; StateAction exit; }; // Function prototypes for state actions void idleEnter(void); void idleExecute(void); void idleExit(void); void selectingEnter(void); void selectingExecute(void); void selectingExit(void); void dispensingEnter(void); void dispensingExecute(void); void dispensingExit(void); // State instances State idleState = {idleEnter, idleExecute, idleExit}; State selectingState = {selectingEnter, selectingExecute, selectingExit}; State dispensingState = {dispensingEnter, dispensingExecute, dispensingExit}; // Current state pointer State* currentState = &idleState; // State action functions void idleEnter(void) { printf(\"Entering Idle State\\n\"); } void idleExecute(void) { printf(\"Idle State: Waiting for selection\\n\"); // Simulate event to transition to selecting state currentState = &selectingState; currentState->enter(); } void idleExit(void) { printf(\"Exiting Idle State\\n\"); } void selectingEnter(void) { printf(\"Entering Selecting State\\n\"); } void selectingExecute(void) { printf(\"Selecting State: Making a selection\\n\"); // Simulate event to transition to dispensing state currentState = &dispensingState; currentState->enter(); } void selectingExit(void) { printf(\"Exiting Selecting State\\n\"); } void dispensingEnter(void) { printf(\"Entering Dispensing State\\n\"); } void dispensingExecute(void) { printf(\"Dispensing State: Dispensing item\\n\"); // Simulate event to transition back to idle state currentState = &idleState; currentState->enter(); } void dispensingExit(void) { printf(\"Exiting Dispensing State\\n\"); } // Function to update the state machine void updateStateMachine(void) { currentState->execute(); } int main() { // Initial state entry currentState->enter(); // Simulate state machine updates for (int i = 0; i < 3; i++) { updateStateMachine(); } return 0; } ``` Explanation State Structure: The State structure contains function pointers for the enter, execute, and exit actions. State Instances: Instances of the State structure are created for each state (Idle, Selecting, Dispensing). State Action Functions: Functions that define the actions for each state. State Transitions: The execute function of each state simulates events that cause transitions to other states by updating the currentState pointer and calling the enter function of the new state. State Machine Update: The updateStateMachine function calls the execute function of the current state. Main Function: Initializes the state machine and simulates state machine updates. Discussion Discussion of Types More on State Machines https://www.youtube.com/watch?v=NTEHRjiAY2I Lecture Outline: State Machines Introduction (5 minutes) Definition: What is a state machine? Importance: Why are state machines crucial in software engineering? Applications: Real-world examples (e.g., vending machines, traffic lights, software protocols). Types of State Machines (5 minutes) Finite State Machines (FSM) Definition and characteristics Examples Deterministic vs. Non-Deterministic FSM Differences and use cases Mealy vs. Moore Machines Definitions and key differences Examples Components of a State Machine (5 minutes) States: Definition and examples Transitions: How states change Events/Inputs: Triggers for transitions Actions/Outputs: Responses to transitions Designing State Machines (10 minutes) State Diagrams: Visual representation Symbols and notation Example diagram State Tables: Tabular representation Structure and usage Example table Best Practices: Tips for designing effective state machines Simplifying complex systems Avoiding common pitfalls Case Study (5 minutes) Example Project: Walkthrough of a state machine in a software project Problem statement State diagram and table Implementation overview Q&A and Discussion (5 minutes) Open floor for questions Discussion on advanced topics or specific student interests Additional Tips: Interactive Elements: Include quick polls or questions to engage students. Visual Aids: Use diagrams and tables to illustrate concepts clearly. Real-World Examples: Relate theoretical concepts to practical applications.","title":"Statemachines"},{"location":"statemachines/#types-of-state-machines","text":"HSM - Heirarchichal State Machines FSM - Finite State Machine","title":"Types of State Machines"},{"location":"statemachines/#background","text":"What are state machines Linking state machines to the behavior of contolled objects Linking state machines to events and time Processes, Transitions, and Constraints","title":"Background"},{"location":"statemachines/#design-guidance","text":"Changes in enviornment state Needed behavioral changes in the application Example:","title":"Design Guidance"},{"location":"statemachines/#elements-in-a-state-machine","text":"Activities State Transitions","title":"Elements in a State Machine"},{"location":"statemachines/#modeling-state-machines","text":"Modeling techniques for State Machines State Diagrams, State Charts UML SysML","title":"Modeling State Machines"},{"location":"statemachines/#example-for-state-machine-implementations","text":"","title":"Example for State Machine Implementations"},{"location":"statemachines/#implementing-state-machines","text":"Conditional Statements Code Snippet ```C switch (currentState) { case STATE_IDLE: if (event == EVENT_START) { // Transition to next state currentState = STATE_RUNNING; } break; case STATE_RUNNING: if (event == EVENT_STOP) { // Transition to idle state currentState = STATE_IDLE; } break; // Add more states as needed } ``` - Discussion - Pros/Cons Lookup Tables Code Snippet TODO: Modify example ```C","title":"Implementing State Machines"},{"location":"statemachines/#include","text":"// Define states typedef enum { STATE_RED, STATE_GREEN, STATE_YELLOW, STATE_MAX } State; // Define events typedef enum { EVENT_TIMER_EXPIRED, EVENT_MAX } Event; // Function prototypes for state actions void redAction(void); void greenAction(void); void yellowAction(void); // State transition structure typedef struct { State currentState; Event event; State nextState; void (*action)(void); } StateTransition; // State transition table StateTransition stateTable[] = { {STATE_RED, EVENT_TIMER_EXPIRED, STATE_GREEN, greenAction}, {STATE_GREEN, EVENT_TIMER_EXPIRED, STATE_YELLOW, yellowAction}, {STATE_YELLOW, EVENT_TIMER_EXPIRED, STATE_RED, redAction} }; // Current state State currentState = STATE_RED; // State action functions void redAction(void) { printf(\"Red Light\\n\"); } void greenAction(void) { printf(\"Green Light\\n\"); } void yellowAction(void) { printf(\"Yellow Light\\n\"); } // Function to handle events void handleEvent(Event event) { for (int i = 0; i < sizeof(stateTable) / sizeof(StateTransition); i++) { if (stateTable[i].currentState == currentState && stateTable[i].event == event) { stateTable[i].action(); currentState = stateTable[i].nextState; break; } } } int main() { // Simulate timer events for (int i = 0; i < 6; i++) { handleEvent(EVENT_TIMER_EXPIRED); } return 0; } ``` - Explanation State and Event Definitions: Enumerations are used to define the states and events. State Transition Table: An array of StateTransition structures maps the current state and event to the next state and the action to be performed. State Action Functions: Functions that define the actions for each state. Event Handling: The handleEvent function iterates through the state transition table to find the matching state and event, performs the action, and updates the current state. Main Function: Simulates timer events to demonstrate the state transitions. Discussion Pros/Cons State Pattern Code Snippet ```C typedef struct State { void ( enter)(void); void ( execute)(void); void (*exit)(void); } State; State idleState = {idleEnter, idleExecute, idleExit}; State runningState = {runningEnter, runningExecute, runningExit}; State* currentState = &idleState; void changeState(State* newState) { currentState->exit(); currentState = newState; currentState->enter(); } void update() { currentState->execute(); }","title":"include "},{"location":"statemachines/#include_1","text":"// Forward declarations of state structures typedef struct State State; // Function pointers for state actions typedef void (*StateAction)(void); // State structure struct State { StateAction enter; StateAction execute; StateAction exit; }; // Function prototypes for state actions void idleEnter(void); void idleExecute(void); void idleExit(void); void selectingEnter(void); void selectingExecute(void); void selectingExit(void); void dispensingEnter(void); void dispensingExecute(void); void dispensingExit(void); // State instances State idleState = {idleEnter, idleExecute, idleExit}; State selectingState = {selectingEnter, selectingExecute, selectingExit}; State dispensingState = {dispensingEnter, dispensingExecute, dispensingExit}; // Current state pointer State* currentState = &idleState; // State action functions void idleEnter(void) { printf(\"Entering Idle State\\n\"); } void idleExecute(void) { printf(\"Idle State: Waiting for selection\\n\"); // Simulate event to transition to selecting state currentState = &selectingState; currentState->enter(); } void idleExit(void) { printf(\"Exiting Idle State\\n\"); } void selectingEnter(void) { printf(\"Entering Selecting State\\n\"); } void selectingExecute(void) { printf(\"Selecting State: Making a selection\\n\"); // Simulate event to transition to dispensing state currentState = &dispensingState; currentState->enter(); } void selectingExit(void) { printf(\"Exiting Selecting State\\n\"); } void dispensingEnter(void) { printf(\"Entering Dispensing State\\n\"); } void dispensingExecute(void) { printf(\"Dispensing State: Dispensing item\\n\"); // Simulate event to transition back to idle state currentState = &idleState; currentState->enter(); } void dispensingExit(void) { printf(\"Exiting Dispensing State\\n\"); } // Function to update the state machine void updateStateMachine(void) { currentState->execute(); } int main() { // Initial state entry currentState->enter(); // Simulate state machine updates for (int i = 0; i < 3; i++) { updateStateMachine(); } return 0; } ``` Explanation State Structure: The State structure contains function pointers for the enter, execute, and exit actions. State Instances: Instances of the State structure are created for each state (Idle, Selecting, Dispensing). State Action Functions: Functions that define the actions for each state. State Transitions: The execute function of each state simulates events that cause transitions to other states by updating the currentState pointer and calling the enter function of the new state. State Machine Update: The updateStateMachine function calls the execute function of the current state. Main Function: Initializes the state machine and simulates state machine updates. Discussion","title":"include "},{"location":"statemachines/#discussion-of-types","text":"","title":"Discussion of Types"},{"location":"statemachines/#more-on-state-machines","text":"https://www.youtube.com/watch?v=NTEHRjiAY2I","title":"More on State Machines"},{"location":"statemachines/#lecture-outline-state-machines","text":"Introduction (5 minutes) Definition: What is a state machine? Importance: Why are state machines crucial in software engineering? Applications: Real-world examples (e.g., vending machines, traffic lights, software protocols). Types of State Machines (5 minutes) Finite State Machines (FSM) Definition and characteristics Examples Deterministic vs. Non-Deterministic FSM Differences and use cases Mealy vs. Moore Machines Definitions and key differences Examples Components of a State Machine (5 minutes) States: Definition and examples Transitions: How states change Events/Inputs: Triggers for transitions Actions/Outputs: Responses to transitions Designing State Machines (10 minutes) State Diagrams: Visual representation Symbols and notation Example diagram State Tables: Tabular representation Structure and usage Example table Best Practices: Tips for designing effective state machines Simplifying complex systems Avoiding common pitfalls Case Study (5 minutes) Example Project: Walkthrough of a state machine in a software project Problem statement State diagram and table Implementation overview Q&A and Discussion (5 minutes) Open floor for questions Discussion on advanced topics or specific student interests Additional Tips: Interactive Elements: Include quick polls or questions to engage students. Visual Aids: Use diagrams and tables to illustrate concepts clearly. Real-World Examples: Relate theoretical concepts to practical applications.","title":"Lecture Outline: State Machines"},{"location":"syllabus/","text":"Course Description This course will introduce students to the design and implementation of sensor-based systems within an embedded systems context. The course's major components are design documentation and C based implementation based on that design. Throughout the course we will be discussing different design notions and study the workings of sensors, embedded systems, and wireless sensor nodes. Prior Knowledge Students taking this course should have some prior experience with IoT or embedded devices, but it isn\u2019t a hard prerequisite. Having hobbyist or classroom experience working with Arduino or Raspberry PI is beneficial but a prerequisite. The course has significant programming components, requiring writing C code compiled on the gcc compiler. The class will require proficiency with C/C++ to succeed. No prior knowledge of sensors or wireless systems is necessary. Learning Objectives After completing this course, you will be able to: \u2022 Design system pieces using standard graphical notation in documentation as well as documenting code \u2022 Build (code) parts of sensor based embedded systems from previously designed elements \u2022 Evaluate the effectiveness of software designs in guiding software implementations","title":"About"},{"location":"syllabus/#course-description","text":"This course will introduce students to the design and implementation of sensor-based systems within an embedded systems context. The course's major components are design documentation and C based implementation based on that design. Throughout the course we will be discussing different design notions and study the workings of sensors, embedded systems, and wireless sensor nodes.","title":"Course Description"},{"location":"syllabus/#prior-knowledge","text":"Students taking this course should have some prior experience with IoT or embedded devices, but it isn\u2019t a hard prerequisite. Having hobbyist or classroom experience working with Arduino or Raspberry PI is beneficial but a prerequisite. The course has significant programming components, requiring writing C code compiled on the gcc compiler. The class will require proficiency with C/C++ to succeed. No prior knowledge of sensors or wireless systems is necessary.","title":"Prior Knowledge"},{"location":"syllabus/#learning-objectives","text":"After completing this course, you will be able to: \u2022 Design system pieces using standard graphical notation in documentation as well as documenting code \u2022 Build (code) parts of sensor based embedded systems from previously designed elements \u2022 Evaluate the effectiveness of software designs in guiding software implementations","title":"Learning Objectives"}]}